{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "app-settings.js",
    "browser-adapter.js",
    "browser.js",
    "countdown-timer.js",
    "formatted-time.js",
    "index.js",
    "node_modules/emittery/index.js",
    "templates.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "'use strict';\n\nconst CHOICES = {\n    numWords : {\n        3 : 3,\n        5 : 5\n    },\n    nGramLength : {\n        2 : 2,\n        3 : 3\n    },\n    time : {\n        30 : 30,\n        45 : 45,\n        60 : 60,\n        120 : 120\n    }\n};\nconst DEFAULTS = {\n    numWords : CHOICES.numWords[5],\n    nGramLength : CHOICES.nGramLength[3],\n    time : CHOICES.time[60]\n};\n\n\nconst validator = {\n    set : (obj, prop, value) => {\n        obj[prop] = CHOICES[prop].hasOwnProperty(value) ? \n            value :\n            DEFAULTS[prop];\n\n        return true;\n    }\n};\n\nclass AppSettings {\n    constructor(settings = {}) {\n        this.settings = new Proxy(Object.assign({}, DEFAULTS), validator);\n        this.reset(settings);\n        return this;\n    }\n\n    reset(settings = {}) {\n        const { numWords, nGramLength, time } = settings;\n        this.settings.numWords = numWords;\n        this.settings.nGramLength = nGramLength;\n        this.settings.time = time;\n        return this;\n    }\n\n    numWords() {\n        return this.settings.numWords;\n    }\n\n    nGramLength() {\n        return this.settings.nGramLength;\n    }\n\n    time() {\n        return this.settings.time;\n    }\n}\n\nmodule.exports = AppSettings;\n",
    "if (typeof Symbol !== 'function') {\n    const Symbol = (input) => {\n        return input;\n    };\n}\nconst { appTemplate, timerTemplate } = require('./templates');\n\n// This verbose syntax is so the cache-busting script notices these URLs\nconst NGRAM_FILES = {\n    2 : './public/ngrams/2-letters.json',\n    3 : './public/ngrams/3-letters.json'\n};\n\nconst SEEN_STORAGE_KEY = 'seenNGrams';\n\nconst debounce = (fn, time, thisContext) => {\n    let timeout;\n\n    return function() {\n        const withContext = fn.apply(thisContext || this, arguments);\n        clearTimeout(timeout);\n        timeout = window.setTimeout(withContext, time);\n    }\n};\n\nconst moveCursorToEnd = (el) => {\n\tif (typeof el.selectionStart == \"number\") {\n\t\tel.selectionStart = el.selectionEnd = el.value.length;\n        el.focus();\n\t} else if (typeof el.createTextRange != \"undefined\") {\n\t\tel.focus();\n\t\tconst range = el.createTextRange();\n\t\trange.collapse(false);\n\t\trange.select();\n\t}\n}\n\n\n/* PRIVATE INSTANCE METHOD SETUP */\nconst \n    guess = Symbol('guess'),\n    handleSettingsOpen = Symbol('handleSettingsOpen'),\n    handleSettingsCancel = Symbol('handleSettingsCancel'),\n    handleSkip = Symbol('handleSkip'),\n    guessHandler = Symbol('guessHandler'),\n    saveSettings = Symbol('saveSettings'),\n    renderApp = Symbol('renderApp'),\n    updateTimer = Symbol('updateTimer'),\n    bindEvents = Symbol('bindEvents');\n\nclass BrowserAdapter {\n    constructor(EventEmitter) {\n        this.emitter = new EventEmitter();\n    }\n\n    /* *\n     *\n     * PUBLIC INTERFACE \n     *\n     * */\n\n    /* SETUP*/\n    loadNGramData(ngramLength) {\n        return new Promise((resolve, reject) => {\n            fetch(NGRAM_FILES[ngramLength]).then((response) => {\n                if (response.status >= 400) {\n                    // no-op\n                    console.log(\"request failed\");\n                    reject();\n                }\n                return response.json();\n            }).then(data => {\n                resolve(data);\n            });\n        });\n    }\n\n    /* LOCAL STORAGE CACHE */\n    retrieveSeenCache() {\n        let seenNGrams = localStorage.getItem(SEEN_STORAGE_KEY);\n        if (seenNGrams) {\n            try {\n                seenNGrams = Object.assign({}, JSON.parse(seenNGrams));\n            }\n            catch(err) {\n                console.log(err);\n                seenNGrams = {};\n            }\n        } else {\n            seenNGrams = {};\n        }\n        return seenNGrams;\n    }\n\n    updateSeenCache(seenData) {\n        try {\n            let data = JSON.stringify(seenData);\n            localStorage.setItem(SEEN_STORAGE_KEY, data);\n        }\n        catch(err) {\n            console.log(err);\n        }\n    }\n\n    /* RENDERING */\n\n    beginNewRound(renderData) {\n        this[renderApp](renderData);\n    }\n\n    recordWin(renderData) {\n        this[renderApp](renderData);\n    }\n\n    recordLoss(renderData) {\n        this[renderApp](renderData);\n    }\n\n    recordCorrectGuess(renderData) {\n        this[renderApp](renderData);\n    }\n\n    showTimeRemaining({remainingTime, originalTime}) {\n        this[updateTimer](remainingTime, (originalTime / 60 >= 1));\n    }\n\n    launchSettingsEditor(renderData) {\n        this[renderApp](renderData);\n        document.getElementById('settingsForm').addEventListener('submit', this[saveSettings].bind(this));\n        document.getElementById('cancelEditSettings').addEventListener('click', this[handleSettingsCancel].bind(this));\n    }\n\n    closeSettingsEditor(renderData) {\n        document.getElementById('settingsForm').removeEventListener('submit', this[saveSettings].bind(this));\n        document.getElementById('cancelEditSettings').removeEventListener('click', this[handleSettingsCancel].bind(this));\n        this[renderApp](renderData);\n    }\n\n\n    /* *\n     *\n     * PRIVATE METHODS\n     *\n     * */\n\n    [guess](input) {\n        this.emitter.emit('guess', input);\n    }\n\n\n    /* EVENT HANDLING */\n    [handleSettingsOpen](e) {\n        e.preventDefault();\n        this.emitter.emit('edit-settings');\n    }\n\n    [handleSettingsCancel](e) {\n        e.preventDefault();\n        this.emitter.emit('cancel-edit-settings');\n    }\n\n    [handleSkip](e) {\n        e.preventDefault();\n        this.emitter.emit('skip-to-next');\n    }\n\n    [guessHandler](e) {\n        const input = e.target.value.trim().toLowerCase();\n        this[guess](input);\n    };\n\n    [saveSettings](e) {\n        e.preventDefault();\n\n        const form = e.target;\n        const nGramLength = parseInt(\n            document.getElementById('numberOfLettersSelector').value\n        );\n        const numWords = parseInt(\n            document.getElementById('numberOfWordsSelector').value\n        );\n        const time = parseInt(\n            document.getElementById('timeLimitSelector').value\n        );\n        this.emitter.emit('settings-change', {\n            nGramLength,\n            numWords,\n            time\n        });\n    }\n\n    /* RENDERING */\n    [renderApp](renderData) {\n        document.body.innerHTML = appTemplate(renderData);\n        this[bindEvents]();\n        moveCursorToEnd(document.getElementById('guessInput'));\n    }\n\n    [updateTimer](remainingTime, showMinutes) {\n        document.getElementById('timerContainer').innerHTML =\n            timerTemplate(remainingTime, showMinutes);\n    }\n\n    [bindEvents]() {\n        document.getElementById('guessInput').addEventListener('keyup', debounce(this[guessHandler], 50, this));\n        document.getElementById('settingsLink').addEventListener('click', this[handleSettingsOpen].bind(this));\n        document.getElementById('skipToNext').addEventListener('click', this[handleSkip].bind(this));\n        document.addEventListener('keypress', (e) => {\n            if ((e.keyCode === 13 || e.code === \"Enter\") && e.target.id === 'guessInput') {\n                e.preventDefault();\n            }\n        });\n    }\n}\n\nmodule.exports = BrowserAdapter;\n",
    "const EventEmitter = require('emittery');\nconst BrowserAdapter = require('./browser-adapter');\nconst index = require('./index');\n\nindex.start(EventEmitter, new BrowserAdapter(EventEmitter));\n\n/* --------------HI THERE!------------------ */\nnavigator.serviceWorker && navigator.serviceWorker.register('./public/sw.js', { scope : '/' }).then(function(registration) {\n      console.log('Excellent, registered with scope: ', registration.scope);\n});\n",
    "class CountdownTimer {\n    constructor(duration, eventEmitter) {\n        this.duration = duration;\n        this.remaining = duration;\n        this.running = false;\n        this.emitter = eventEmitter;\n        this._tick = this._tick.bind(this);\n        return this;\n    }\n    tick() {\n        this.nextTick = setTimeout(this._tick, 1000);\n        return this;\n    }\n    _tick() {\n        if (this.running) {\n            this.remaining--;\n            this.emitter.emit('tick', this.remaining);\n            if (this.remaining) {\n                this.tick();\n            } else {\n                this.running = false;\n                this.emitter.emit('zero');\n            }\n        }\n        return this;\n    }\n    start() {\n        this.running = true;\n        this.tick();\n        return this;\n    }\n    pause () {\n        clearTimeout(this.nextTick);\n        this.running = false;\n        return this;\n    }\n    clear () {\n        clearTimeout(this.nextTick);\n        this.running = false;\n        this.remaining = this.duration;\n        return this;\n    }\n    changeDuration (duration) {\n        if (!this.running) {\n            this.duration = duration;\n            this.clear();\n        }\n        return this;\n    }\n}\n\nmodule.exports = CountdownTimer;\n",
    "module.exports = formattedTime = (remaining, showMinutes = false) => {\n    const minutes = remaining / 60;\n    const minutesInt = Math.floor(minutes);\n    let seconds = remaining % 60;\n    if (seconds < 10) {\n        seconds = '0' + seconds;\n    }\n    return (minutesInt || '') + ':' + seconds;\n};\n",
    "\"use strict\";\n\nconst CountdownTimer = require('./countdown-timer');\nconst AppSettings = require('./app-settings');\n\n\nconst nGramDataDefaults = () => {\n    return {\n        hash : {},\n        arr : [],\n        seen : {},\n        count : 0\n    };\n};\nlet nGramData;\n\nconst setObjProperty = (obj, key, val) => {\n    if (obj.hasOwnProperty(key)) {\n        obj[key] = val;\n    }\n};\nconst setViaHashOrPair = (targetObj, key, val) => {\n    if (typeof key === 'string') {\n        setObjProperty(targetObj, key, val);\n    } else\n    if (typeof key === 'object') {\n        const obj = key;\n        for (let k in obj) {\n            setObjProperty(targetObj, k, obj[k]);\n        }\n    }\n};\n\nconst currentNGramDefaults = () => {\n   return {\n        ngram : '',\n        words : [],\n        hash : {},\n        guessed : 0,\n        recentCorrectGuess : null,\n        inputValue : '',\n        win : false,\n        lose : false,\n        editingSettings : false\n    }\n};\n\nclass NGramGame {\n    constructor(ioAdapter, timer, settings) {\n        const currentNGram = currentNGramDefaults();\n        let recentGuessTimer;\n\n        this.getCurrent = () => currentNGram;\n        this.setCurrent = (...args) => {\n            setViaHashOrPair(currentNGram, ...args);\n        };\n        this.setAsGuessed = (word) => {\n            currentNGram.hash[word] = true;\n            currentNGram.guessed++;\n            currentNGram.recentCorrectGuess = word;\n            currentNGram.inputValue = '';\n            clearTimeout(recentGuessTimer);\n            recentGuessTimer = setTimeout(() => {\n                currentNGram.recentCorrectGuess = null;\n            }, 5000);\n        };\n\n        this.ioAdapter = ioAdapter;\n        this.ioAdapter.emitter.on('guess', this.guess.bind(this));\n        this.ioAdapter.emitter.on('settings-change', this.changeSettings.bind(this));\n        this.ioAdapter.emitter.on('edit-settings', this.launchSettingsEditor.bind(this));\n        this.ioAdapter.emitter.on('cancel-edit-settings', this.closeSettingsEditor.bind(this));\n        this.ioAdapter.emitter.on('skip-to-next', this.skipToNext.bind(this));\n\n        this.timer = timer;\n        // this.timer.emitter.on('zero', this.loseRound.bind(this));\n        this.timer.emitter.on('tick', (remaining) => {\n            this.ioAdapter.showTimeRemaining(this.renderData());\n            if (remaining === 0) {\n                this.loseRound();\n            }\n        });\n        \n        this.settings = settings;\n\n        return this;\n    }\n\n    winRound() {\n        this.timer.pause();\n        this.setCurrent('win', true);\n        this.ioAdapter.recordWin(this.renderData());\n        setTimeout(this.newRound.bind(this), 5000);\n        return this;\n    }\n\n    loseRound() {\n        this.setCurrent({\n            inputValue : '',\n            lose : true\n        });\n        this.ioAdapter.recordLoss(this.renderData());\n        setTimeout(this.newRound.bind(this), 5000);\n        return this;\n    }\n\n    skipToNext() {\n        this.timer.pause();\n        this.loseRound();\n        return this;\n    }\n\n    guess(guess) {\n        this.setCurrent('inputValue', guess);\n\n        const correctAndNew = this.getCurrent().hash.hasOwnProperty(guess) && this.getCurrent().hash[guess] === false;\n        if (correctAndNew) {\n            this.recordCorrectGuess(guess);\n        }\n        return this;\n    }\n\n    recordCorrectGuess(guess) {\n        this.setAsGuessed(guess);\n        if (this.getCurrent().guessed === this.settings.numWords()) {\n            this.winRound();\n        } else {\n            this.ioAdapter.recordCorrectGuess(this.renderData());\n        }\n        return this;\n    }\n\n    newRound() {\n        const ngram = randomNGram()\n        const words = nGramData.hash[ngram].slice(0, this.settings.numWords());\n\n        this.setCurrent(Object.assign({}, currentNGramDefaults(), {\n            ngram : ngram,\n            words : words,\n            hash : words.reduce((acc, word) => {\n                acc[word] = false;\n                return acc;\n            }, {})\n        }));\n        if (this.settings.time() !== this.timer.duration) {\n            this.timer.changeDuration(this.settings.time());\n        }\n        this.timer.clear().start();\n        this.ioAdapter.beginNewRound(this.renderData());\n\n        nGramData.seen[ngram] = true;\n        this.ioAdapter.updateSeenCache(nGramData.seen);\n    }\n\n    launchSettingsEditor() {\n        this.timer.pause();\n        this.setCurrent('editingSettings', true);\n        this.ioAdapter.launchSettingsEditor(this.renderData());\n    }\n\n    changeSettings(settings) {\n        let load = false;\n        if (settings.nGramLength !== this.settings.nGramLength()) {\n            load = true;\n        }\n        this.settings.reset(settings);\n        this.setCurrent('editingSettings', false);\n\n        if (load) {\n            this.ioAdapter.loadNGramData(this.settings.nGramLength()).then((data) => {\n                nGramData = storeNGramData(data, nGramData.seen);\n                this.newRound();\n            });\n        } else {\n            this.newRound();\n        }\n    }\n\n    closeSettingsEditor() {\n        this.setCurrent('editingSettings', false);\n        this.ioAdapter.closeSettingsEditor(this.renderData());\n        this.timer.start();\n    }\n\n    renderData() {\n        return Object.assign({}, this.getCurrent(), {\n            originalTime : this.timer.duration,\n            remainingTime : this.timer.remaining,\n            numWords : this.settings.numWords(),\n            ngramLength : this.settings.nGramLength()\n        });\n    }\n}\n\nconst storeNGramData = (data, seen) => {\n    const _nGramData = Object.assign(nGramDataDefaults(), {\n        hash : data,\n        arr : Object.keys(data),\n        count : Object.keys(data).length,\n    });\n    if (seen) {\n        _nGramData.seen = seen;\n    }\n    return _nGramData;\n};\n\nconst randomNGram = (i = 0) => {\n    if (i >= nGramData.count) {\n        nGramData.seen = {};\n        updateSeenCache({});\n    }\n\n    const index = Math.floor(\n        Math.random() * (nGramData.count)\n    );\n    const ngram = nGramData.arr[index];\n    return nGramData.seen[ngram] ? \n        randomNGram(i+1) :\n        ngram;\n};\n\nconst start = (EventEmitter, ioAdapter, settings) => {\n    const appSettings = new AppSettings(settings);\n    const timer = new CountdownTimer(appSettings.time(), new EventEmitter());\n\n    ioAdapter.loadNGramData(appSettings.nGramLength()).then((data) => {\n        nGramData = storeNGramData(data, ioAdapter.retrieveSeenCache());\n        const game = new NGramGame(\n            ioAdapter,\n            timer,\n            appSettings\n        ).newRound();\n    }, (err) => {\n        console.log(err);\n    });\n};\n\nmodule.exports = { start };\n",
    "'use strict';\n\nconst anyMap = new WeakMap();\nconst eventsMap = new WeakMap();\nconst resolvedPromise = Promise.resolve();\n\nfunction assertEventName(eventName) {\n\tif (typeof eventName !== 'string') {\n\t\tthrow new TypeError('eventName must be a string');\n\t}\n}\n\nfunction assertListener(listener) {\n\tif (typeof listener !== 'function') {\n\t\tthrow new TypeError('listener must be a function');\n\t}\n}\n\nfunction getListeners(instance, eventName) {\n\tconst events = eventsMap.get(instance);\n\tif (!events.has(eventName)) {\n\t\tevents.set(eventName, new Set());\n\t}\n\n\treturn events.get(eventName);\n}\n\nclass Emittery {\n\tconstructor() {\n\t\tanyMap.set(this, new Set());\n\t\teventsMap.set(this, new Map());\n\t}\n\n\ton(eventName, listener) {\n\t\tassertEventName(eventName);\n\t\tassertListener(listener);\n\t\tgetListeners(this, eventName).add(listener);\n\t\treturn this.off.bind(this, eventName, listener);\n\t}\n\n\toff(eventName, listener) {\n\t\tassertEventName(eventName);\n\t\tassertListener(listener);\n\t\tgetListeners(this, eventName).delete(listener);\n\t}\n\n\tonce(eventName) {\n\t\treturn new Promise(resolve => {\n\t\t\tassertEventName(eventName);\n\t\t\tconst off = this.on(eventName, data => {\n\t\t\t\toff();\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\tasync emit(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\treturn Promise.all([\n\t\t\t...staticListeners.map(async listener => {\n\t\t\t\tif (listeners.has(listener)) {\n\t\t\t\t\treturn listener(eventData);\n\t\t\t\t}\n\t\t\t}),\n\t\t\t...staticAnyListeners.map(async listener => {\n\t\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\t\treturn listener(eventName, eventData);\n\t\t\t\t}\n\t\t\t})\n\t\t]);\n\t}\n\n\tasync emitSerial(eventName, eventData) {\n\t\tassertEventName(eventName);\n\n\t\tconst listeners = getListeners(this, eventName);\n\t\tconst anyListeners = anyMap.get(this);\n\t\tconst staticListeners = [...listeners];\n\t\tconst staticAnyListeners = [...anyListeners];\n\n\t\tawait resolvedPromise;\n\t\t/* eslint-disable no-await-in-loop */\n\t\tfor (const listener of staticListeners) {\n\t\t\tif (listeners.has(listener)) {\n\t\t\t\tawait listener(eventData);\n\t\t\t}\n\t\t}\n\n\t\tfor (const listener of staticAnyListeners) {\n\t\t\tif (anyListeners.has(listener)) {\n\t\t\t\tawait listener(eventName, eventData);\n\t\t\t}\n\t\t}\n\t\t/* eslint-enable no-await-in-loop */\n\t}\n\n\tonAny(listener) {\n\t\tassertListener(listener);\n\t\tanyMap.get(this).add(listener);\n\t\treturn this.offAny.bind(this, listener);\n\t}\n\n\toffAny(listener) {\n\t\tassertListener(listener);\n\t\tanyMap.get(this).delete(listener);\n\t}\n\n\tclearListeners(eventName) {\n\t\tif (typeof eventName === 'string') {\n\t\t\tgetListeners(this, eventName).clear();\n\t\t} else {\n\t\t\tanyMap.get(this).clear();\n\t\t\tfor (const listeners of eventsMap.get(this).values()) {\n\t\t\t\tlisteners.clear();\n\t\t\t}\n\t\t}\n\t}\n\n\tlistenerCount(eventName) {\n\t\tif (typeof eventName === 'string') {\n\t\t\treturn anyMap.get(this).size + getListeners(this, eventName).size;\n\t\t}\n\n\t\tif (typeof eventName !== 'undefined') {\n\t\t\tassertEventName(eventName);\n\t\t}\n\n\t\tlet count = anyMap.get(this).size;\n\n\t\tfor (const value of eventsMap.get(this).values()) {\n\t\t\tcount += value.size;\n\t\t}\n\n\t\treturn count;\n\t}\n}\n\n// Subclass used to encourage TS users to type their events.\nEmittery.Typed = class extends Emittery {};\nObject.defineProperty(Emittery.Typed, 'Typed', {\n\tenumerable: false,\n\tvalue: undefined\n});\n\nmodule.exports = Emittery;\n",
    "const formattedTime = require('./formatted-time');\n\nconst app = ({numWords, ngramLength, ngram, inputValue, hash, words, remainingTime, originalTime, win, lose, editingSettings}) => {\n    const showMinutes = originalTime / 60 >= 1;\n    return (\n        nav() +\n        h1(numWords, ngram, lose || win) +\n        form(inputValue, remainingTime, showMinutes) +\n        scoreBoard(words, hash, win, lose) +\n        (win ? winNotification() : '') +\n        (editingSettings ? settingsEditor(ngramLength, numWords, originalTime) : '')\n    );\n};\n\nconst nav = () => {\n    return `<nav>\n        <a href=\"/\" id=\"homeLink\" class=\"home-link\" title=\"TBH, this just refreshes the page\">TopWords.me</a>\n        <a href=\"#settings\" id=\"settingsLink\" class=\"settings-link\" title=\"Change gameplay settings\">Settings</a>\n    </nav>`;\n};\n\nconst h1 = (numWords, ngram, gameOver) => {\n    return `<h1>\n        Top ${numWords} words starting with\n        <var>\n            ${ngram}\n        </var>\n        ${gameOver ? \n            '<a id=\"skipToNext\" class=\"skip-to-next busy\" title=\"Loading next round\">&hellip;</a>' :\n            '<a href=\"/\" id=\"skipToNext\" class=\"skip-to-next\" title=\"Give up\">I give up</a>'\n        }\n    </h1>`;\n};\n\nconst scoreBoard = (words, hash, win, lose) => {\n    return `<ol>\n        ${words.map(wordBlank(hash, win, lose)).join('\\n')}\n    </ol>`;\n};\n\nconst wordBlank = (hash, win, lose) => (word) => {\n    const guessed = hash[word];\n    return `<li class=\"${guessed ? 'correct recent' : (lose ? 'incorrect' : '')}\">${guessed || win || lose ? word : '&nbsp'}</li>`;\n};\n\nconst form = (inputValue, remainingTime, showMinutes) => {\n    return `<form class=\"guess-word\">\n        <input type=\"text\"\n            id=\"guessInput\"\n            value=\"${inputValue}\"\n            placeholder=\"Type your guess\"\n            autocapitalize=\"off\" \n            autocomplete=\"off\"\n            spellcheck=\"false\" \n            autocorrect=\"off\" />\n        ${timerContainer(remainingTime, showMinutes)}\n    </form>`;\n};\n\nconst timerContainer = (remaining, showMinutes) => {\n    return `<div id=\"timerContainer\">\n        ${timer(remaining, showMinutes)}\n    </div>`;\n};\n\nconst timer = (remaining, showMinutes) => {\n    return `<time id=\"remainingTime\" class=\"${remaining < 10 ? 'low-remainder' : ''}\">${formattedTime(remaining, showMinutes)}</time>`;\n};\n\nconst winNotification = () => {\n    return '<h2 id=\"winNotification\">ðŸŽ‰ You won! ðŸŽ‰</h2>';\n};\n\nconst settingsEditor = (ngramLength, numWords, originalTime) => {\n    return `<aside id=\"settingsEditor\">\n        <h2>Edit settings</h2>\n        <form id=\"settingsForm\" class=\"settings-editor\">\n            <label for=\"numberOfLettersSelector\">Number of letters</label>\n            <select id=\"numberOfLettersSelector\" name=\"ngramLength\">\n                <option value=\"2\" ${ngramLength === 2 ? 'selected' : ''}>2</option>\n                <option value=\"3\" ${ngramLength === 3 ? 'selected' : ''}>3</option>\n            </select>\n\n            <label for=\"numberOfWordsSelector\">Number of words</label>\n            <select id=\"numberOfWordsSelector\" name=\"numWords\">\n                <option value=\"3\" ${numWords === 3 ? 'selected' : ''}>3</option>\n                <option value=\"5\" ${numWords === 5 ? 'selected' : ''}>5</option>\n            </select>\n\n            <label for=\"timeLimitSelector\">Time limit</label>\n            <select id=\"timeLimitSelector\" name=\"time\">\n                <option value=\"30\" ${originalTime === 30 ? 'selected' : ''}>30 seconds</option>\n                <option value=\"45\" ${originalTime === 45 ? 'selected' : ''}>45 seconds</option>\n                <option value=\"60\" ${originalTime === 60 ? 'selected' : ''}>1 minute</option>\n                <option value=\"120\" ${originalTime === 120 ? 'selected' : ''}>2 minutes</option>\n            </select>\n\n            <button type=\"submit\">\n                Play\n            </button>\n            <a href=\"#\" id=\"cancelEditSettings\">Cancel</a>\n        </form>\n    </aside>`;\n};\n\nmodule.exports = { appTemplate : app, timerTemplate : timer };\n"
  ]
}